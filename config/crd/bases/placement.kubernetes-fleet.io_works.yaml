---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.15.0
  name: works.placement.kubernetes-fleet.io
spec:
  group: placement.kubernetes-fleet.io
  names:
    categories:
    - fleet
    - fleet-placement
    kind: Work
    listKind: WorkList
    plural: works
    singular: work
  scope: Namespaced
  versions:
  - name: v1
    schema:
      openAPIV3Schema:
        description: Work is the Schema for the works API.
        properties:
          apiVersion:
            description: |-
              APIVersion defines the versioned schema of this representation of an object.
              Servers should convert recognized schemas to the latest internal value, and
              may reject unrecognized values.
              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            type: string
          kind:
            description: |-
              Kind is a string value representing the REST resource this object represents.
              Servers may infer this from the endpoint the client submits requests to.
              Cannot be updated.
              In CamelCase.
              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            type: string
          metadata:
            type: object
          spec:
            description: spec defines the workload of a work.
            properties:
              applyStrategy:
                description: |-
                  ApplyStrategy describes how to resolve the conflict if the resource to be placed already exists in the target cluster
                  and is owned by other appliers.
                  This field is a beta-level feature.
                properties:
                  allowCoOwnership:
                    description: |-
                      AllowCoOwnership defines whether to apply the resource if it already exists in the target cluster and is not
                      solely owned by fleet (i.e., metadata.ownerReferences contains only fleet custom resources).
                      If true, apply the resource and add fleet as a co-owner.
                      If false, leave the resource unchanged and fail the apply.
                    type: boolean
                  serverSideApplyConfig:
                    description: ServerSideApplyConfig defines the configuration for
                      server side apply. It is honored only when type is ServerSideApply.
                    properties:
                      force:
                        description: |-
                          Force represents to force apply to succeed when resolving the conflicts
                          For any conflicting fields,
                          - If true, use the values from the resource to be applied to overwrite the values of the existing resource in the
                          target cluster, as well as take over ownership of such fields.
                          - If false, apply will fail with the reason ApplyConflictWithOtherApplier.


                          For non-conflicting fields, values stay unchanged and ownership are shared between appliers.
                        type: boolean
                    type: object
                  type:
                    default: ClientSideApply
                    description: |-
                      Type defines the type of strategy to use. Default to ClientSideApply.
                      Server-side apply is a safer choice. Read more about the differences between server-side apply and client-side
                      apply: https://kubernetes.io/docs/reference/using-api/server-side-apply/#comparison-with-client-side-apply.
                    enum:
                    - ClientSideApply
                    - ServerSideApply
                    type: string
                type: object
              workload:
                description: Workload represents the manifest workload to be deployed
                  on spoke cluster
                properties:
                  manifests:
                    description: Manifests represents a list of kuberenetes resources
                      to be deployed on the spoke cluster.
                    items:
                      description: Manifest represents a resource to be deployed on
                        spoke cluster.
                      type: object
                      x-kubernetes-embedded-resource: true
                      x-kubernetes-preserve-unknown-fields: true
                    type: array
                type: object
            type: object
          status:
            description: status defines the status of each applied manifest on the
              spoke cluster.
            properties:
              conditions:
                description: |-
                  Conditions contains the different condition statuses for this work.
                  Valid condition types are:
                  1. Applied represents workload in Work is applied successfully on the spoke cluster.
                  2. Progressing represents workload in Work in the trasitioning from one state to another the on the spoke cluster.
                  3. Available represents workload in Work exists on the spoke cluster.
                  4. Degraded represents the current state of workload does not match the desired
                  state for a certain period.
                items:
                  description: "Condition contains details for one aspect of the current
                    state of this API Resource.\n---\nThis struct is intended for
                    direct use as an array at the field path .status.conditions.  For
                    example,\n\n\n\ttype FooStatus struct{\n\t    // Represents the
                    observations of a foo's current state.\n\t    // Known .status.conditions.type
                    are: \"Available\", \"Progressing\", and \"Degraded\"\n\t    //
                    +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    // +listType=map\n\t
                    \   // +listMapKey=type\n\t    Conditions []metav1.Condition `json:\"conditions,omitempty\"
                    patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t
                    \   // other fields\n\t}"
                  properties:
                    lastTransitionTime:
                      description: |-
                        lastTransitionTime is the last time the condition transitioned from one status to another.
                        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                      format: date-time
                      type: string
                    message:
                      description: |-
                        message is a human readable message indicating details about the transition.
                        This may be an empty string.
                      maxLength: 32768
                      type: string
                    observedGeneration:
                      description: |-
                        observedGeneration represents the .metadata.generation that the condition was set based upon.
                        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                        with respect to the current state of the instance.
                      format: int64
                      minimum: 0
                      type: integer
                    reason:
                      description: |-
                        reason contains a programmatic identifier indicating the reason for the condition's last transition.
                        Producers of specific condition types may define expected values and meanings for this field,
                        and whether the values are considered a guaranteed API.
                        The value should be a CamelCase string.
                        This field may not be empty.
                      maxLength: 1024
                      minLength: 1
                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$
                      type: string
                    status:
                      description: status of the condition, one of True, False, Unknown.
                      enum:
                      - "True"
                      - "False"
                      - Unknown
                      type: string
                    type:
                      description: |-
                        type of condition in CamelCase or in foo.example.com/CamelCase.
                        ---
                        Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
                        useful (see .node.status.conditions), the ability to deconflict is important.
                        The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                      maxLength: 316
                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$
                      type: string
                  required:
                  - lastTransitionTime
                  - message
                  - reason
                  - status
                  - type
                  type: object
                type: array
              manifestConditions:
                description: |-
                  ManifestConditions represents the conditions of each resource in work deployed on
                  spoke cluster.
                items:
                  description: |-
                    ManifestCondition represents the conditions of the resources deployed on
                    spoke cluster.
                  properties:
                    conditions:
                      description: Conditions represents the conditions of this resource
                        on spoke cluster
                      items:
                        description: "Condition contains details for one aspect of
                          the current state of this API Resource.\n---\nThis struct
                          is intended for direct use as an array at the field path
                          .status.conditions.  For example,\n\n\n\ttype FooStatus
                          struct{\n\t    // Represents the observations of a foo's
                          current state.\n\t    // Known .status.conditions.type are:
                          \"Available\", \"Progressing\", and \"Degraded\"\n\t    //
                          +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    //
                          +listType=map\n\t    // +listMapKey=type\n\t    Conditions
                          []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\"
                          patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t
                          \   // other fields\n\t}"
                        properties:
                          lastTransitionTime:
                            description: |-
                              lastTransitionTime is the last time the condition transitioned from one status to another.
                              This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                            format: date-time
                            type: string
                          message:
                            description: |-
                              message is a human readable message indicating details about the transition.
                              This may be an empty string.
                            maxLength: 32768
                            type: string
                          observedGeneration:
                            description: |-
                              observedGeneration represents the .metadata.generation that the condition was set based upon.
                              For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                              with respect to the current state of the instance.
                            format: int64
                            minimum: 0
                            type: integer
                          reason:
                            description: |-
                              reason contains a programmatic identifier indicating the reason for the condition's last transition.
                              Producers of specific condition types may define expected values and meanings for this field,
                              and whether the values are considered a guaranteed API.
                              The value should be a CamelCase string.
                              This field may not be empty.
                            maxLength: 1024
                            minLength: 1
                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$
                            type: string
                          status:
                            description: status of the condition, one of True, False,
                              Unknown.
                            enum:
                            - "True"
                            - "False"
                            - Unknown
                            type: string
                          type:
                            description: |-
                              type of condition in CamelCase or in foo.example.com/CamelCase.
                              ---
                              Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
                              useful (see .node.status.conditions), the ability to deconflict is important.
                              The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                            maxLength: 316
                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$
                            type: string
                        required:
                        - lastTransitionTime
                        - message
                        - reason
                        - status
                        - type
                        type: object
                      type: array
                    identifier:
                      description: resourceId represents a identity of a resource
                        linking to manifests in spec.
                      properties:
                        group:
                          description: Group is the group of the resource.
                          type: string
                        kind:
                          description: Kind is the kind of the resource.
                          type: string
                        name:
                          description: Name is the name of the resource
                          type: string
                        namespace:
                          description: |-
                            Namespace is the namespace of the resource, the resource is cluster scoped if the value
                            is empty
                          type: string
                        ordinal:
                          description: |-
                            Ordinal represents an index in manifests list, so the condition can still be linked
                            to a manifest even thougth manifest cannot be parsed successfully.
                          type: integer
                        resource:
                          description: Resource is the resource type of the resource
                          type: string
                        version:
                          description: Version is the version of the resource.
                          type: string
                      required:
                      - ordinal
                      type: object
                  required:
                  - conditions
                  type: object
                type: array
            required:
            - conditions
            type: object
        type: object
    served: true
    storage: false
    subresources:
      status: {}
  - name: v1beta1
    schema:
      openAPIV3Schema:
        description: Work is the Schema for the works API.
        properties:
          apiVersion:
            description: |-
              APIVersion defines the versioned schema of this representation of an object.
              Servers should convert recognized schemas to the latest internal value, and
              may reject unrecognized values.
              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            type: string
          kind:
            description: |-
              Kind is a string value representing the REST resource this object represents.
              Servers may infer this from the endpoint the client submits requests to.
              Cannot be updated.
              In CamelCase.
              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            type: string
          metadata:
            type: object
          spec:
            description: spec defines the workload of a work.
            properties:
              applyStrategy:
                description: |-
                  ApplyStrategy describes how to resolve the conflict if the resource to be placed already exists in the target cluster
                  and is owned by other appliers.
                properties:
                  actionType:
                    default: AlwaysApply
                    description: |-
                      TakeoverAction determines the action to take when Fleet applies resources to a member
                      cluster for the first time and finds out that the resource already exists in the cluster.


                      This setting is most relevant in cases where you would like Fleet to manage pre-existing
                      resources on a member cluster.


                      Available options include:


                      * AlwaysApply: with this action, Fleet will apply the hub cluster manifests to the member
                        clusters even if the affected resources already exist. This is the default action.


                        Note that this might lead to some fields being overwritten on the member clusters.


                      * ApplyIfNoDiff: with this action, Fleet will apply the hub cluster manifests to the member
                        clusters if (and only if) pre-existing resources look the same as the hub cluster manifests.
                        This is a safer option as pre-existing resources that are inconsistent with the hub cluster
                        manifests will not be overwritten; in fact, Fleet will ignore them until the inconsistencies
                        are resolved properly: any change you make to the hub cluster manifests would not be
                        applied, and if you delete the manifests or even the ClusterResourcePlacement itself
                        from the hub cluster, these pre-existing resources would not be taken away.


                        Fleet will check for inconsistencies in accordance with the DiffMode setting. See also
                        the comments on the DiffMode field for more information.


                        If a diff has been found in a field that is **managed** by Fleet (i.e., the field
                        **is specified ** in the hub cluster manifest), consider one of the following actions:
                        * set the field in the member cluster to be of the same value as that in the hub cluster
                          manifest.
                        * update the hub cluster manifest so that its field value matches with that in the member
                          cluster.
                        * switch to the AlwaysApply action, which will allow Fleet to overwrite the field with the
                          value in the hub cluster manifest.


                        If a diff has been found in a field that is **not managed** by Fleet (i.e., the field
                        **is not specified** in the hub cluster manifest), consider one of the following actions:
                        * remove the field from the member cluster.
                        * update the hub cluster manifest so that the field is included in the hub cluster manifest.


                        If appropriate, you may also delete the object from the member cluster; Fleet will recreate
                        it using the hub cluster manifest.
                    enum:
                    - AlwaysApply
                    - ApplyIfNoDiff
                    type: string
                  allowCoOwnership:
                    description: |-
                      AllowCoOwnership defines whether to apply the resource if it already exists in the target cluster and is not
                      solely owned by fleet (i.e., metadata.ownerReferences contains only fleet custom resources).
                      If true, apply the resource and add fleet as a co-owner.
                      If false, leave the resource unchanged and fail the apply.
                    type: boolean
                  diffMode:
                    default: ApplyDiff
                    description: |-
                      DiffMode controls the way Fleet calculates inconsistencies between a resource's desired state
                      as kept in the Fleet hub cluster and its current state on the target member cluster.


                      This field is in effect when the ClusterResourcePlacement is configured to use the
                      ReportDiff apply strategy and/or the ApplyIfNoDiff takeover action.


                      Available options include:


                      * ApplyDiff: with this mode, Fleet considers that a placed object has drifted from its
                        desired state if (and only if) there are value differences in fields that are managed
                        by Fleet (i.e., the fields that are specified explicitly in the hub cluster manifests).
                        Differences in unmanaged fields will be ignored. This is the default mode.


                      * FullDiff: with this mode, Fleet considers that a placed object has drifted from its
                        desired state if there are values differences in any object field, even if the field is
                        not managed by Fleet (i.e., the field is not specified in the hub cluster manifest). This
                        effectively assumes that an object must look exactly the same in the hub cluster and the
                        member clusters.


                        If you prefer using this mode, it is recommended that you
                        * specify all the fields of interest explicitly in the hub cluster manifests, even if
                          you are OK with using default values for some fields; and
                        * make sure that no fields are managed by agents other than Fleet in the member clusters,
                          such as HPAs, VPAs, or other controllers.
                    enum:
                    - ApplyDiff
                    - FullDiff
                    type: string
                  serverSideApplyConfig:
                    description: ServerSideApplyConfig defines the configuration for
                      server side apply. It is honored only when type is ServerSideApply.
                    properties:
                      force:
                        description: |-
                          Force represents to force apply to succeed when resolving the conflicts
                          For any conflicting fields,
                          - If true, use the values from the resource to be applied to overwrite the values of the existing resource in the
                          target cluster, as well as take over ownership of such fields.
                          - If false, apply will fail with the reason ApplyConflictWithOtherApplier.


                          For non-conflicting fields, values stay unchanged and ownership are shared between appliers.
                        type: boolean
                    type: object
                  type:
                    default: ClientSideApply
                    description: |-
                      Type is the apply strategy to use; it determines how Fleet applies manifests from the
                      hub cluster to a member cluster.


                      Available options are:


                      * ClientSideApply: Fleet uses three-way merge to apply manifests, similar to how kubectl
                        performs a client-side apply. This is the default option.


                        Note that this strategy requires that Fleet keep the last applied configuration in the
                        annoation of an applied resource. If the object gets so large that apply ops can no longer
                        be executed, Fleet will switch to server-side apply.


                      * ServerSideApply: Fleet uses server-side apply to apply manifests; Fleet itself will
                        become the field manager for specified fields in the manifests. Specify
                        ServerSideApplyConfig as appropriate if you would like Fleet to take over field
                        ownership upon conflicts. This is the recommended option for most scenarios; it might
                        help reduce object size and safely resolve conflicts between field values. For more
                        information, please refer to the Kubernetes documentation
                        (https://kubernetes.io/docs/reference/using-api/server-side-apply/#comparison-with-client-side-apply).


                        Note that with this strategy, any change made to the managed fields by agents other than
                        Fleet in the member cluster will be overwritten periodically. If you would like Fleet
                        to detect such changes and report them rather than overwritting values as soon as Fleet
                        finds the inconsistencies, consider using the ReportDiff strategies.


                      * ReportDiff: Fleet uses server-side apply to apply manifests, and will report
                        that an object has drifted from its desired state if an inconsistency has been found
                        in accordance with the DiffMode setting. This is helpful in drift detection scenarios,
                        where you would like to identify ad-hoc changes made to placed objects in
                        the member clusters.


                        See also the comments on the DiffMode field for more information.


                        If a diff has been found in a field that is managed by Fleet (i.e., the field is specified
                        in the hub cluster manifest), consider one of the following actions:


                        * revert the field change in all drifted member clusters.
                        * update the hub cluster manifest; this will trigger Fleet to apply the latest revision
                          of the manifests, which will overwrite the drifted field.
                        * switch to the ServerSideApply strategy, which will allow Fleet to overwrite the drifted
                          field with the current revision of manifests.


                        If a diff has been found in a field that is not managed by Fleet (i.e., the field is not
                        specified in the hub cluster manifest), consider one of the following actions:


                        * remove the field from all drifted member clusters.
                        * update the hub cluster manifest so that the field is included in the hub cluster
                          manifest.


                      For a comparison between the different strategies and some examples, please refer to the
                      Fleet documentation.
                    enum:
                    - ClientSideApply
                    - ServerSideApply
                    - ReportDiff
                    type: string
                type: object
              workload:
                description: Workload represents the manifest workload to be deployed
                  on spoke cluster
                properties:
                  manifests:
                    description: Manifests represents a list of kuberenetes resources
                      to be deployed on the spoke cluster.
                    items:
                      description: Manifest represents a resource to be deployed on
                        spoke cluster.
                      type: object
                      x-kubernetes-embedded-resource: true
                      x-kubernetes-preserve-unknown-fields: true
                    type: array
                type: object
            type: object
          status:
            description: status defines the status of each applied manifest on the
              spoke cluster.
            properties:
              conditions:
                description: |-
                  Conditions contains the different condition statuses for this work.
                  Valid condition types are:
                  1. Applied represents workload in Work is applied successfully on the spoke cluster.
                  2. Progressing represents workload in Work in the trasitioning from one state to another the on the spoke cluster.
                  3. Available represents workload in Work exists on the spoke cluster.
                  4. Degraded represents the current state of workload does not match the desired
                  state for a certain period.
                items:
                  description: "Condition contains details for one aspect of the current
                    state of this API Resource.\n---\nThis struct is intended for
                    direct use as an array at the field path .status.conditions.  For
                    example,\n\n\n\ttype FooStatus struct{\n\t    // Represents the
                    observations of a foo's current state.\n\t    // Known .status.conditions.type
                    are: \"Available\", \"Progressing\", and \"Degraded\"\n\t    //
                    +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    // +listType=map\n\t
                    \   // +listMapKey=type\n\t    Conditions []metav1.Condition `json:\"conditions,omitempty\"
                    patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t
                    \   // other fields\n\t}"
                  properties:
                    lastTransitionTime:
                      description: |-
                        lastTransitionTime is the last time the condition transitioned from one status to another.
                        This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                      format: date-time
                      type: string
                    message:
                      description: |-
                        message is a human readable message indicating details about the transition.
                        This may be an empty string.
                      maxLength: 32768
                      type: string
                    observedGeneration:
                      description: |-
                        observedGeneration represents the .metadata.generation that the condition was set based upon.
                        For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                        with respect to the current state of the instance.
                      format: int64
                      minimum: 0
                      type: integer
                    reason:
                      description: |-
                        reason contains a programmatic identifier indicating the reason for the condition's last transition.
                        Producers of specific condition types may define expected values and meanings for this field,
                        and whether the values are considered a guaranteed API.
                        The value should be a CamelCase string.
                        This field may not be empty.
                      maxLength: 1024
                      minLength: 1
                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$
                      type: string
                    status:
                      description: status of the condition, one of True, False, Unknown.
                      enum:
                      - "True"
                      - "False"
                      - Unknown
                      type: string
                    type:
                      description: |-
                        type of condition in CamelCase or in foo.example.com/CamelCase.
                        ---
                        Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
                        useful (see .node.status.conditions), the ability to deconflict is important.
                        The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                      maxLength: 316
                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$
                      type: string
                  required:
                  - lastTransitionTime
                  - message
                  - reason
                  - status
                  - type
                  type: object
                type: array
              manifestConditions:
                description: |-
                  ManifestConditions represents the conditions of each resource in work deployed on
                  spoke cluster.
                items:
                  description: |-
                    ManifestCondition represents the conditions of the resources deployed on
                    spoke cluster.
                  properties:
                    conditions:
                      description: Conditions represents the conditions of this resource
                        on spoke cluster
                      items:
                        description: "Condition contains details for one aspect of
                          the current state of this API Resource.\n---\nThis struct
                          is intended for direct use as an array at the field path
                          .status.conditions.  For example,\n\n\n\ttype FooStatus
                          struct{\n\t    // Represents the observations of a foo's
                          current state.\n\t    // Known .status.conditions.type are:
                          \"Available\", \"Progressing\", and \"Degraded\"\n\t    //
                          +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    //
                          +listType=map\n\t    // +listMapKey=type\n\t    Conditions
                          []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\"
                          patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t
                          \   // other fields\n\t}"
                        properties:
                          lastTransitionTime:
                            description: |-
                              lastTransitionTime is the last time the condition transitioned from one status to another.
                              This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                            format: date-time
                            type: string
                          message:
                            description: |-
                              message is a human readable message indicating details about the transition.
                              This may be an empty string.
                            maxLength: 32768
                            type: string
                          observedGeneration:
                            description: |-
                              observedGeneration represents the .metadata.generation that the condition was set based upon.
                              For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                              with respect to the current state of the instance.
                            format: int64
                            minimum: 0
                            type: integer
                          reason:
                            description: |-
                              reason contains a programmatic identifier indicating the reason for the condition's last transition.
                              Producers of specific condition types may define expected values and meanings for this field,
                              and whether the values are considered a guaranteed API.
                              The value should be a CamelCase string.
                              This field may not be empty.
                            maxLength: 1024
                            minLength: 1
                            pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$
                            type: string
                          status:
                            description: status of the condition, one of True, False,
                              Unknown.
                            enum:
                            - "True"
                            - "False"
                            - Unknown
                            type: string
                          type:
                            description: |-
                              type of condition in CamelCase or in foo.example.com/CamelCase.
                              ---
                              Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
                              useful (see .node.status.conditions), the ability to deconflict is important.
                              The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                            maxLength: 316
                            pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$
                            type: string
                        required:
                        - lastTransitionTime
                        - message
                        - reason
                        - status
                        - type
                        type: object
                      type: array
                    identifier:
                      description: resourceId represents a identity of a resource
                        linking to manifests in spec.
                      properties:
                        group:
                          description: Group is the group of the resource.
                          type: string
                        kind:
                          description: Kind is the kind of the resource.
                          type: string
                        name:
                          description: Name is the name of the resource
                          type: string
                        namespace:
                          description: |-
                            Namespace is the namespace of the resource, the resource is cluster scoped if the value
                            is empty
                          type: string
                        ordinal:
                          description: |-
                            Ordinal represents an index in manifests list, so the condition can still be linked
                            to a manifest even thougth manifest cannot be parsed successfully.
                          type: integer
                        resource:
                          description: Resource is the resource type of the resource
                          type: string
                        version:
                          description: Version is the version of the resource.
                          type: string
                      required:
                      - ordinal
                      type: object
                  required:
                  - conditions
                  type: object
                type: array
            required:
            - conditions
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
