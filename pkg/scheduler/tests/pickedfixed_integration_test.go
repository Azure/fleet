/*
Copyright (c) Microsoft Corporation.
Licensed under the MIT license.
*/

package tests

// This test suite features a number of test cases which cover the happy paths of the scheduler
// workflow.

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

	fleetv1beta1 "go.goms.io/fleet/apis/placement/v1beta1"
)

const (
	crpName1 = "crp-1"

	policySnapshotName1 = "policy-snapshot-1"
	policySnapshotName2 = "policy-snapshot-2"
	policySnapshotName3 = "policy-snapshot-3"
	policySnapshotName4 = "policy-snapshot-4"
	policySnapshotName5 = "policy-snapshot-5"

	policyHash = "policy-hash"

	bindingNamePlaceholder = "binding"
)

var (
	defaultResourceSelectors = []fleetv1beta1.ClusterResourceSelector{
		{
			Group:   "core",
			Kind:    "Namespace",
			Version: "v1",
			Name:    "work",
		},
	}
)

var (
	lessFuncBinding = func(binding1, binding2 fleetv1beta1.ClusterResourceBinding) bool {
		return binding1.Spec.TargetCluster < binding2.Spec.TargetCluster
	}
	lessFuncClusterDecison = func(decision1, decision2 fleetv1beta1.ClusterDecision) bool {
		return decision1.ClusterName < decision2.ClusterName
	}

	ignoreClusterDecisionReasonField          = cmpopts.IgnoreFields(fleetv1beta1.ClusterDecision{}, "Reason")
	ignoreObjectMetaNameField                 = cmpopts.IgnoreFields(metav1.ObjectMeta{}, "Name")
	ignoreObjectMetaAutoGeneratedFields       = cmpopts.IgnoreFields(metav1.ObjectMeta{}, "UID", "CreationTimestamp", "ResourceVersion", "Generation", "ManagedFields")
	ignoreResourceBindingTypeMetaField        = cmpopts.IgnoreFields(fleetv1beta1.ClusterResourceBinding{}, "TypeMeta")
	ignoreConditionTimeReasonAndMessageFields = cmpopts.IgnoreFields(metav1.Condition{}, "LastTransitionTime", "Reason", "Message")
)

var (
	noBindingCreatedActual = func() error {
		// List all bindings.
		bindingList := &fleetv1beta1.ClusterResourceBindingList{}
		if err := hubClient.List(ctx, bindingList); err != nil {
			return err
		}

		// Check that the returned list is empty.
		if bindingCount := len(bindingList.Items); bindingCount != 0 {
			return fmt.Errorf("%d bindings have been created unexpectedly", bindingCount)
		}

		return nil
	}

	getCRPSchedulerFinalizerAddedActual = func(crpName string) func() error {
		return func() error {
			// Retrieve the CRP.
			crp := &fleetv1beta1.ClusterResourcePlacement{}
			if err := hubClient.Get(ctx, types.NamespacedName{Name: crpName}, crp); err != nil {
				return err
			}

			// Check that the scheduler finalizer has been added.
			if !controllerutil.ContainsFinalizer(crp, fleetv1beta1.SchedulerCRPCleanupFinalizer) {
				return fmt.Errorf("scheduler cleanup finalizer has not been added")
			}

			return nil
		}
	}

	getCRPSchedulerFinalizerRemovedActual = func(crpName string) func() error {
		return func() error {
			// Retrieve the CRP.
			crp := &fleetv1beta1.ClusterResourcePlacement{}
			if err := hubClient.Get(ctx, types.NamespacedName{Name: crpName}, crp); err != nil {
				return err
			}

			// Check that the scheduler finalizer has been added.
			if controllerutil.ContainsFinalizer(crp, fleetv1beta1.SchedulerCRPCleanupFinalizer) {
				return fmt.Errorf("scheduler cleanup finalizer is still present")
			}

			return nil
		}
	}

	getScheduledBindingsCreatedForClustersActual = func(clusters []string, crpName, policySnapshotName string) func() error {
		return func() error {
			// List all bindings.
			bindingList := &fleetv1beta1.ClusterResourceBindingList{}
			if err := hubClient.List(ctx, bindingList); err != nil {
				return err
			}

			// Find all the scheduled bindings.
			scheduled := []fleetv1beta1.ClusterResourceBinding{}
			for _, binding := range bindingList.Items {
				if binding.Spec.State == fleetv1beta1.BindingStateScheduled {
					scheduled = append(scheduled, binding)
				}
			}

			// Verify that scheduled bindings are created as expected.
			wantScheduled := []fleetv1beta1.ClusterResourceBinding{}
			for _, name := range clusters {
				binding := fleetv1beta1.ClusterResourceBinding{
					ObjectMeta: metav1.ObjectMeta{
						Name: bindingNamePlaceholder,
						Labels: map[string]string{
							fleetv1beta1.CRPTrackingLabel: crpName,
						},
					},
					Spec: fleetv1beta1.ResourceBindingSpec{
						State:                        fleetv1beta1.BindingStateScheduled,
						SchedulingPolicySnapshotName: policySnapshotName,
						TargetCluster:                name,
						ClusterDecision: fleetv1beta1.ClusterDecision{
							ClusterName: name,
							Selected:    true,
						},
					},
				}
				wantScheduled = append(wantScheduled, binding)
			}

			if diff := cmp.Diff(
				scheduled,
				wantScheduled,
				ignoreResourceBindingTypeMetaField,
				ignoreObjectMetaNameField,
				ignoreObjectMetaAutoGeneratedFields,
				ignoreClusterDecisionReasonField,
				cmpopts.SortSlices(lessFuncBinding),
			); diff != "" {
				return fmt.Errorf("scheduled bindings are not created as expected; diff (-got, +want): %s", diff)
			}

			// Verify that binding names are formatted correctly.
			for _, binding := range bindingList.Items {
				wantPrefix := fmt.Sprintf("%s-%s", crpName1, binding.Spec.TargetCluster)
				if !strings.HasPrefix(binding.Name, wantPrefix) {
					return fmt.Errorf("binding name %s is not formatted correctly; want prefix %s", binding.Name, wantPrefix)
				}
			}

			return nil
		}
	}

	getPolicySnapshotStatusUpdatedActual = func(valid, invalidOrNotFound []string, policySnapshotName string) func() error {
		return func() error {
			policySnapshot := &fleetv1beta1.ClusterSchedulingPolicySnapshot{}
			if err := hubClient.Get(ctx, types.NamespacedName{Name: policySnapshotName}, policySnapshot); err != nil {
				return err
			}

			// Verify that the observed CRP generation field is populated correctly.
			wantCRPGeneration := policySnapshot.Annotations[fleetv1beta1.CRPGenerationAnnotation]
			observedCRPGeneration := policySnapshot.Status.ObservedCRPGeneration
			if strconv.FormatInt(observedCRPGeneration, 10) != wantCRPGeneration {
				return fmt.Errorf("policy snapshot observed CRP generation not match: want %s, got %d", wantCRPGeneration, observedCRPGeneration)
			}

			// Verify that cluster decisons are populated correctly.
			wantClusterDecisons := []fleetv1beta1.ClusterDecision{}
			for _, clusterName := range valid {
				wantClusterDecisons = append(wantClusterDecisons, fleetv1beta1.ClusterDecision{
					ClusterName: clusterName,
					Selected:    true,
				})
			}
			for _, clusterName := range invalidOrNotFound {
				wantClusterDecisons = append(wantClusterDecisons, fleetv1beta1.ClusterDecision{
					ClusterName: clusterName,
					Selected:    false,
				})
			}
			if diff := cmp.Diff(policySnapshot.Status.ClusterDecisions, wantClusterDecisons, ignoreClusterDecisionReasonField, cmpopts.SortSlices(lessFuncClusterDecison)); diff != "" {
				return fmt.Errorf("policy snapshot status cluster decisions (-got, +want): %s", diff)
			}

			// Verify that the scheduled condition is added correctly.
			scheduledCondition := meta.FindStatusCondition(policySnapshot.Status.Conditions, string(fleetv1beta1.PolicySnapshotScheduled))
			var wantScheduledCondition *metav1.Condition
			if len(invalidOrNotFound) == 0 {
				wantScheduledCondition = &metav1.Condition{
					Type:               string(fleetv1beta1.PolicySnapshotScheduled),
					Status:             metav1.ConditionTrue,
					ObservedGeneration: policySnapshot.Generation,
				}
			} else {
				wantScheduledCondition = &metav1.Condition{
					Type:               string(fleetv1beta1.PolicySnapshotScheduled),
					Status:             metav1.ConditionFalse,
					ObservedGeneration: policySnapshot.Generation,
				}
			}
			if diff := cmp.Diff(scheduledCondition, wantScheduledCondition, ignoreConditionTimeReasonAndMessageFields); diff != "" {
				return fmt.Errorf("policy snapshot status scheduled condition (-got, +want): %s", diff)
			}

			return nil
		}
	}

	getNoBindingsCreatedForClustersActual = func(clusters []string) func() error {
		// Build a map for clusters for quicker lookup.
		clusterMap := map[string]bool{}
		for _, name := range clusters {
			clusterMap[name] = true
		}

		return func() error {
			bindingList := &fleetv1beta1.ClusterResourceBindingList{}
			if err := hubClient.List(ctx, bindingList); err != nil {
				return err
			}

			bindings := bindingList.Items
			for _, binding := range bindings {
				if _, ok := clusterMap[binding.Spec.TargetCluster]; ok {
					return fmt.Errorf("binding %s for cluster %s has been created unexpectedly", binding.Name, binding.Spec.TargetCluster)
				}
			}

			return nil
		}
	}

	getBoundBindingsUpdatedForClustersActual = func(clusters []string, crpName, policySnapshotName string) func() error {
		return func() error {
			bindingList := &fleetv1beta1.ClusterResourceBindingList{}
			if err := hubClient.List(ctx, bindingList); err != nil {
				return err
			}

			bound := []fleetv1beta1.ClusterResourceBinding{}
			for _, binding := range bindingList.Items {
				if binding.Spec.State == fleetv1beta1.BindingStateBound {
					bound = append(bound, binding)
				}
			}

			wantBound := []fleetv1beta1.ClusterResourceBinding{}
			for _, name := range clusters {
				binding := fleetv1beta1.ClusterResourceBinding{
					ObjectMeta: metav1.ObjectMeta{
						Name: bindingNamePlaceholder,
						Labels: map[string]string{
							fleetv1beta1.CRPTrackingLabel: crpName,
						},
					},
					Spec: fleetv1beta1.ResourceBindingSpec{
						State:                        fleetv1beta1.BindingStateBound,
						SchedulingPolicySnapshotName: policySnapshotName,
						TargetCluster:                name,
						ClusterDecision: fleetv1beta1.ClusterDecision{
							ClusterName: name,
							Selected:    true,
						},
					},
				}
				wantBound = append(wantBound, binding)
			}

			if diff := cmp.Diff(
				bound,
				wantBound,
				ignoreResourceBindingTypeMetaField,
				ignoreObjectMetaNameField,
				ignoreObjectMetaAutoGeneratedFields,
				ignoreClusterDecisionReasonField,
				cmpopts.SortSlices(lessFuncBinding),
			); diff != "" {
				return fmt.Errorf("bound bindings are not updated as expected; diff (-got, +want): %s", diff)
			}

			// Verify that binding names are formatted correctly.
			for _, binding := range bindingList.Items {
				wantPrefix := fmt.Sprintf("%s-%s", crpName1, binding.Spec.TargetCluster)
				if !strings.HasPrefix(binding.Name, wantPrefix) {
					return fmt.Errorf("binding name %s is not formatted correctly; want prefix %s", binding.Name, wantPrefix)
				}
			}

			return nil
		}
	}

	getScheduledBindingsUpdatedForClustersActual = func(clusters []string, crpName, policySnapshotName string) func() error {
		return func() error {
			bindingList := &fleetv1beta1.ClusterResourceBindingList{}
			if err := hubClient.List(ctx, bindingList); err != nil {
				return err
			}

			scheduled := []fleetv1beta1.ClusterResourceBinding{}
			for _, binding := range bindingList.Items {
				if binding.Spec.State == fleetv1beta1.BindingStateScheduled {
					scheduled = append(scheduled, binding)
				}
			}

			wantScheduled := []fleetv1beta1.ClusterResourceBinding{}
			for _, name := range clusters {
				binding := fleetv1beta1.ClusterResourceBinding{
					ObjectMeta: metav1.ObjectMeta{
						Name: bindingNamePlaceholder,
						Labels: map[string]string{
							fleetv1beta1.CRPTrackingLabel: crpName,
						},
					},
					Spec: fleetv1beta1.ResourceBindingSpec{
						State:                        fleetv1beta1.BindingStateScheduled,
						SchedulingPolicySnapshotName: policySnapshotName,
						TargetCluster:                name,
						ClusterDecision: fleetv1beta1.ClusterDecision{
							ClusterName: name,
							Selected:    true,
						},
					},
				}
				wantScheduled = append(wantScheduled, binding)
			}

			if diff := cmp.Diff(
				scheduled,
				wantScheduled,
				ignoreResourceBindingTypeMetaField,
				ignoreObjectMetaNameField,
				ignoreObjectMetaAutoGeneratedFields,
				ignoreClusterDecisionReasonField,
				cmpopts.SortSlices(lessFuncBinding),
			); diff != "" {
				return fmt.Errorf("scheduled bindings are not updated as expected; diff (-got, +want): %s", diff)
			}

			// Verify that binding names are formatted correctly.
			for _, binding := range bindingList.Items {
				wantPrefix := fmt.Sprintf("%s-%s", crpName1, binding.Spec.TargetCluster)
				if !strings.HasPrefix(binding.Name, wantPrefix) {
					return fmt.Errorf("binding name %s is not formatted correctly; want prefix %s", binding.Name, wantPrefix)
				}
			}

			return nil
		}
	}

	getUnscheduledBindingsCreatedForClustersActual = func(clusters []string, crpName, policySnapshotName string) func() error {
		return func() error {
			bindingList := &fleetv1beta1.ClusterResourceBindingList{}
			if err := hubClient.List(ctx, bindingList); err != nil {
				return err
			}

			unscheduled := []fleetv1beta1.ClusterResourceBinding{}
			for _, binding := range bindingList.Items {
				if binding.Spec.State == fleetv1beta1.BindingStateUnscheduled {
					unscheduled = append(unscheduled, binding)
				}
			}

			wantUnscheduled := []fleetv1beta1.ClusterResourceBinding{}
			for _, name := range clusters {
				binding := fleetv1beta1.ClusterResourceBinding{
					ObjectMeta: metav1.ObjectMeta{
						Name: bindingNamePlaceholder,
						Labels: map[string]string{
							fleetv1beta1.CRPTrackingLabel: crpName,
						},
					},
					Spec: fleetv1beta1.ResourceBindingSpec{
						State:                        fleetv1beta1.BindingStateUnscheduled,
						SchedulingPolicySnapshotName: policySnapshotName,
						TargetCluster:                name,
						ClusterDecision: fleetv1beta1.ClusterDecision{
							ClusterName: name,
							Selected:    true,
						},
					},
				}
				wantUnscheduled = append(wantUnscheduled, binding)
			}

			if diff := cmp.Diff(
				unscheduled,
				wantUnscheduled,
				ignoreResourceBindingTypeMetaField,
				ignoreObjectMetaNameField,
				ignoreObjectMetaAutoGeneratedFields,
				ignoreClusterDecisionReasonField,
				cmpopts.SortSlices(lessFuncBinding),
			); diff != "" {
				return fmt.Errorf("unscheduled bindings are not updated as expected; diff (-got, +want): %s", diff)
			}

			// Verify that binding names are formatted correctly.
			for _, binding := range bindingList.Items {
				wantPrefix := fmt.Sprintf("%s-%s", crpName1, binding.Spec.TargetCluster)
				if !strings.HasPrefix(binding.Name, wantPrefix) {
					return fmt.Errorf("binding name %s is not formatted correctly; want prefix %s", binding.Name, wantPrefix)
				}
			}

			return nil
		}
	}
)

var (
	updatePickedFixedCRPWithNewTargetClustersAndRefreshSnapshots = func(crpName string, targetClusters []string, oldPolicySnapshotName, newPolicySnapshotName string) {
		// Update the CRP.
		crp := &fleetv1beta1.ClusterResourcePlacement{}
		Expect(hubClient.Get(ctx, types.NamespacedName{Name: crpName1}, crp)).To(Succeed(), "Failed to get CRP")

		policy := crp.Spec.Policy.DeepCopy()
		policy.ClusterNames = targetClusters
		crp.Spec.Policy = policy
		Expect(hubClient.Update(ctx, crp)).To(Succeed(), "Failed to update CRP")

		crpGeneration := crp.Generation

		// Mark the old policy snapshot as inactive.
		policySnapshot := &fleetv1beta1.ClusterSchedulingPolicySnapshot{}
		Expect(hubClient.Get(ctx, types.NamespacedName{Name: oldPolicySnapshotName}, policySnapshot)).To(Succeed(), "Failed to get policy snapshot")
		policySnapshot.Labels[fleetv1beta1.IsLatestSnapshotLabel] = strconv.FormatBool(false)
		Expect(hubClient.Update(ctx, policySnapshot)).To(Succeed(), "Failed to update policy snapshot")

		// Create a new policy snapshot.
		policySnapshot = &fleetv1beta1.ClusterSchedulingPolicySnapshot{
			ObjectMeta: metav1.ObjectMeta{
				Name: newPolicySnapshotName,
				Labels: map[string]string{
					fleetv1beta1.IsLatestSnapshotLabel: strconv.FormatBool(true),
					fleetv1beta1.CRPTrackingLabel:      crpName1,
				},
				Annotations: map[string]string{
					fleetv1beta1.CRPGenerationAnnotation: strconv.FormatInt(crpGeneration, 10),
				},
			},
			Spec: fleetv1beta1.SchedulingPolicySnapshotSpec{
				Policy:     policy,
				PolicyHash: []byte(policyHash),
			},
		}
		Expect(hubClient.Create(ctx, policySnapshot)).To(Succeed(), "Failed to create policy snapshot")
	}

	clearUnscheduledBindings = func() {
		// List all bindings.
		bindingList := &fleetv1beta1.ClusterResourceBindingList{}
		Expect(hubClient.List(ctx, bindingList)).To(Succeed(), "Failed to list bindings")

		// Delete all unscheduled bindings.
		for idx := range bindingList.Items {
			binding := bindingList.Items[idx]
			if binding.Spec.State == fleetv1beta1.BindingStateUnscheduled {
				Expect(hubClient.Delete(ctx, &binding)).To(Succeed(), "Failed to delete binding")

				Eventually(func() error {
					err := hubClient.Get(ctx, types.NamespacedName{Name: binding.Name}, &fleetv1beta1.ClusterResourceBinding{})
					if errors.IsNotFound(err) {
						return nil
					}

					return err
				}, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to delete binding")
			}
		}
	}
)

var _ = Describe("scheduling CRPs of the PickFixed placement type", Serial, Ordered, func() {
	Context("create a CRP with some valid target clusters", func() {
		targetClusters := []string{
			memberCluster1,
			memberCluster4,
			memberCluster6,
		}

		BeforeAll(func() {
			// Ensure that no bindings have been created so far.
			Consistently(noBindingCreatedActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Some bindings have been created unexpectedly")

			policy := &fleetv1beta1.PlacementPolicy{
				PlacementType: fleetv1beta1.PickFixedPlacementType,
				ClusterNames:  targetClusters,
			}

			// Create the CRP.
			crp := &fleetv1beta1.ClusterResourcePlacement{
				ObjectMeta: metav1.ObjectMeta{
					Name: crpName1,
				},
				Spec: fleetv1beta1.ClusterResourcePlacementSpec{
					ResourceSelectors: defaultResourceSelectors,
					Policy:            policy,
				},
			}
			Expect(hubClient.Create(ctx, crp)).To(Succeed(), "Failed to create CRP")

			crpGeneration := crp.Generation

			// Create the associated policy snapshot.
			policySnapshot := &fleetv1beta1.ClusterSchedulingPolicySnapshot{
				ObjectMeta: metav1.ObjectMeta{
					Name: policySnapshotName1,
					Labels: map[string]string{
						fleetv1beta1.IsLatestSnapshotLabel: strconv.FormatBool(true),
						fleetv1beta1.CRPTrackingLabel:      crpName1,
					},
					Annotations: map[string]string{
						fleetv1beta1.CRPGenerationAnnotation: strconv.FormatInt(crpGeneration, 10),
					},
				},
				Spec: fleetv1beta1.SchedulingPolicySnapshotSpec{
					Policy:     policy,
					PolicyHash: []byte(policyHash),
				},
			}
			Expect(hubClient.Create(ctx, policySnapshot)).To(Succeed(), "Failed to create policy snapshot")
		})

		It("should add scheduler cleanup finalizer to the CRP", func() {
			schedulerCleanupFinalizerAddedActual := getCRPSchedulerFinalizerAddedActual(crpName1)
			Eventually(schedulerCleanupFinalizerAddedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to add scheduler cleanup finalizer to CRP")
		})

		It("should create scheduled bindings for valid target clusters", func() {
			scheduledBindingsCreatedForClustersActual := getScheduledBindingsCreatedForClustersActual(targetClusters, crpName1, policySnapshotName1)
			Eventually(scheduledBindingsCreatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to create the expected set of bindings")
			Consistently(scheduledBindingsCreatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to create the expected set of bindings")
		})

		It("should report status correctly", func() {
			policySnapshotStatusUpdatedActual := getPolicySnapshotStatusUpdatedActual(targetClusters, []string{}, policySnapshotName1)
			Eventually(policySnapshotStatusUpdatedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to report correct policy snapshot status")
			Consistently(policySnapshotStatusUpdatedActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to report correct policy snapshot status")
		})
	})

	Context("add additional valid target clusters", func() {
		targetClusters := []string{
			memberCluster1,
			memberCluster2,
			memberCluster4,
			memberCluster5,
			memberCluster6,
		}

		boundClusters := []string{
			memberCluster1,
			memberCluster4,
			memberCluster6,
		}
		scheduledClusters := []string{
			memberCluster2,
			memberCluster5,
		}

		BeforeAll(func() {
			// Mark all previously created bindings as bound.
			bindingList := &fleetv1beta1.ClusterResourceBindingList{}
			Expect(hubClient.List(ctx, bindingList)).To(Succeed(), "Failed to list bindings")
			for idx := range bindingList.Items {
				binding := bindingList.Items[idx]
				if binding.Spec.State == fleetv1beta1.BindingStateScheduled {
					binding.Spec.State = fleetv1beta1.BindingStateBound
					Expect(hubClient.Update(ctx, &binding)).To(Succeed(), "Failed to update binding")
				}
			}

			// Update the CRP with new target clusters and refresh scheduling policy snapshots.
			updatePickedFixedCRPWithNewTargetClustersAndRefreshSnapshots(crpName1, targetClusters, policySnapshotName1, policySnapshotName2)
		})

		It("should create scheduled bindings for newly added valid target clusters", func() {
			scheduledBindingsCreatedForClustersActual := getScheduledBindingsCreatedForClustersActual(scheduledClusters, crpName1, policySnapshotName2)
			Eventually(scheduledBindingsCreatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to create the expected set of bindings")
			Consistently(scheduledBindingsCreatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to create the expected set of bindings")
		})

		It("should update bound bindings for previously added valid target clusters", func() {
			boundBindingsUpdatedForClustersActual := getBoundBindingsUpdatedForClustersActual(boundClusters, crpName1, policySnapshotName2)
			Eventually(boundBindingsUpdatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
			Consistently(boundBindingsUpdatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
		})

		It("should report status correctly", func() {
			policySnapshotStatusUpdatedActual := getPolicySnapshotStatusUpdatedActual(targetClusters, []string{}, policySnapshotName2)
			Eventually(policySnapshotStatusUpdatedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update policy snapshot status")
			Consistently(policySnapshotStatusUpdatedActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update policy snapshot status")
		})
	})

	Context("add invalid (unhealthy, or left) and not found target clusters", func() {
		targetClusters := []string{
			memberCluster1,
			memberCluster2,
			memberCluster4,
			memberCluster5,
			memberCluster6,
			memberCluster8,  // cluster runningwolf is an invalid cluster (unhealthy).
			memberCluster9,  // cluster walkingeagle is an invalid cluster (left).
			memberCluster10, // cluster blueflamingo cannot be found in the fleet.
		}

		validClusters := []string{
			memberCluster1,
			memberCluster2,
			memberCluster4,
			memberCluster5,
			memberCluster6,
		}
		boundClusters := []string{
			memberCluster1,
			memberCluster4,
			memberCluster6,
		}
		scheduledClusters := []string{
			memberCluster2,
			memberCluster5,
		}

		invalidClusters := []string{
			memberCluster8,
			memberCluster9,
			memberCluster10,
		}

		BeforeAll(func() {
			// Update the CRP with new target clusters and refresh scheduling policy snapshots.
			updatePickedFixedCRPWithNewTargetClustersAndRefreshSnapshots(crpName1, targetClusters, policySnapshotName2, policySnapshotName3)
		})

		It("should update bound bindings for previously added valid target clusters", func() {
			boundBindingsUpdatedForClustersActual := getBoundBindingsUpdatedForClustersActual(boundClusters, crpName1, policySnapshotName3)
			Eventually(boundBindingsUpdatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
			Consistently(boundBindingsUpdatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
		})

		It("should update scheduled bindings for previously added valid target clusters", func() {
			scheduledBindingsUpdatedForClustersActual := getScheduledBindingsUpdatedForClustersActual(scheduledClusters, crpName1, policySnapshotName3)
			Eventually(scheduledBindingsUpdatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
			Consistently(scheduledBindingsUpdatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
		})

		It("should not create bindings for invalid target clusters", func() {
			noBindingsCreatedForClustersActual := getNoBindingsCreatedForClustersActual(invalidClusters)
			Eventually(noBindingsCreatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Created a binding for invalid or not found cluster")
			Consistently(noBindingsCreatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Created a binding for invalid or not found cluster")
		})

		It("should report status correctly", func() {
			policySnapshotStatusUpdatedActual := getPolicySnapshotStatusUpdatedActual(validClusters, invalidClusters, policySnapshotName3)
			Eventually(policySnapshotStatusUpdatedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update policy snapshot status")
			Consistently(policySnapshotStatusUpdatedActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update policy snapshot status")
		})
	})

	Context("remove some target clusters (valid + invalid)", func() {
		targetClusters := []string{
			memberCluster2,
			memberCluster5,
			memberCluster6,
			memberCluster8,
			memberCluster10,
		}

		validClusters := []string{
			memberCluster2,
			memberCluster5,
			memberCluster6,
		}
		boundClusters := []string{
			memberCluster6,
		}
		scheduledClusters := []string{
			memberCluster2,
			memberCluster5,
		}

		invalidClusters := []string{
			memberCluster8,
			memberCluster10,
		}

		unscheduledClusters := []string{
			memberCluster1,
			memberCluster4,
		}

		BeforeAll(func() {
			// Update the CRP with new target clusters and refresh scheduling policy snapshots.
			updatePickedFixedCRPWithNewTargetClustersAndRefreshSnapshots(crpName1, targetClusters, policySnapshotName3, policySnapshotName4)
		})

		It("should update bound bindings for previously added valid target clusters", func() {
			boundBindingsUpdatedForClustersActual := getBoundBindingsUpdatedForClustersActual(boundClusters, crpName1, policySnapshotName4)
			Eventually(boundBindingsUpdatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
			Consistently(boundBindingsUpdatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
		})

		It("should update scheduled bindings for previously added valid target clusters", func() {
			scheduledBindingsUpdatedForClustersActual := getScheduledBindingsUpdatedForClustersActual(scheduledClusters, crpName1, policySnapshotName4)
			Eventually(scheduledBindingsUpdatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
			Consistently(scheduledBindingsUpdatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update the expected set of bindings")
		})

		It("should mark bindings as unscheduled for removed valid target clusters", func() {
			unscheduledBindingsCreatedForClustersActual := getUnscheduledBindingsCreatedForClustersActual(unscheduledClusters, crpName1, policySnapshotName3)
			Eventually(unscheduledBindingsCreatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to mark bindings as unscheduled")
			Consistently(unscheduledBindingsCreatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to mark bindings as unscheduled")
		})

		It("should not create bindings for invalid target clusters", func() {
			noBindingsCreatedForClustersActual := getNoBindingsCreatedForClustersActual(invalidClusters)
			Eventually(noBindingsCreatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Created a binding for invalid or not found cluster")
			Consistently(noBindingsCreatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Created a binding for invalid or not found cluster")
		})

		It("should report status correctly", func() {
			policySnapshotStatusUpdatedActual := getPolicySnapshotStatusUpdatedActual(validClusters, invalidClusters, policySnapshotName4)
			Eventually(policySnapshotStatusUpdatedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update policy snapshot status")
			Consistently(policySnapshotStatusUpdatedActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update policy snapshot status")
		})

		AfterAll(func() {
			clearUnscheduledBindings()
		})
	})

	Context("pick a different set of clusters", func() {
		targetClusters := []string{
			memberCluster3,
			memberCluster7,
		}

		validClusters := []string{
			memberCluster3,
			memberCluster7,
		}
		scheduledClusters := []string{
			memberCluster3,
			memberCluster7,
		}

		unscheduledClusters := []string{
			memberCluster2,
			memberCluster5,
			memberCluster6,
		}

		BeforeAll(func() {
			// Update the CRP with new target clusters and refresh scheduling policy snapshots.
			updatePickedFixedCRPWithNewTargetClustersAndRefreshSnapshots(crpName1, targetClusters, policySnapshotName4, policySnapshotName5)
		})

		It("should create scheduled bindings for newly added valid target clusters", func() {
			scheduledBindingsCreatedForClustersActual := getScheduledBindingsCreatedForClustersActual(scheduledClusters, crpName1, policySnapshotName5)
			Eventually(scheduledBindingsCreatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to create the expected set of bindings")
			Consistently(scheduledBindingsCreatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to create the expected set of bindings")
		})

		It("should not have any bound bindings", func() {
			noBoundBindingsActual := getBoundBindingsUpdatedForClustersActual([]string{}, crpName1, policySnapshotName5)
			Eventually(noBoundBindingsActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Unexpected bound bindings are present")
			Consistently(noBoundBindingsActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Unexpected bound bindings are present")
		})

		It("should mark bindings as unscheduled for removed valid target clusters", func() {
			unscheduledBindingsCreatedForClustersActual := getUnscheduledBindingsCreatedForClustersActual(unscheduledClusters, crpName1, policySnapshotName4)
			Eventually(unscheduledBindingsCreatedForClustersActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to mark bindings as unscheduled")
			Consistently(unscheduledBindingsCreatedForClustersActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to mark bindings as unscheduled")
		})

		It("should report status correctly", func() {
			policySnapshotStatusUpdatedActual := getPolicySnapshotStatusUpdatedActual(validClusters, []string{}, policySnapshotName5)
			Eventually(policySnapshotStatusUpdatedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to update policy snapshot status")
			Consistently(policySnapshotStatusUpdatedActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to update policy snapshot status")
		})
	})

	Context("CRP deleted", func() {
		additionalFinalizer := "test-purpose-finalizer"

		BeforeAll(func() {
			// Retrieve the CRP.
			crp := &fleetv1beta1.ClusterResourcePlacement{}
			Expect(hubClient.Get(ctx, types.NamespacedName{Name: crpName1}, crp)).To(Succeed(), "Failed to get CRP")

			// Ensure that the CRP has the scheduler cleanup finalizer.
			Expect(controllerutil.ContainsFinalizer(crp, fleetv1beta1.SchedulerCRPCleanupFinalizer)).To(BeTrue(), "CRP does not have the scheduler cleanup finalizer")

			// Add an additional finalizer to the CRP to block its deletion; this helps to better
			// observe the scheduler's behavior.
			controllerutil.AddFinalizer(crp, additionalFinalizer)
			Expect(hubClient.Update(ctx, crp)).To(Succeed(), "Failed to update CRP")

			// Delete the CRP.
			Expect(hubClient.Delete(ctx, crp)).To(Succeed(), "Failed to delete CRP")
		})

		It("should clear all bindings", func() {
			Eventually(noBindingCreatedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to clear all bindings")
			Consistently(noBindingCreatedActual, consistentlyDuration, consistentlyInterval).Should(Succeed(), "Failed to clear all bindings")
		})

		It("should remove the scheduler cleanup finalizer from the CRP", func() {
			schedulerCleanupFinalizerRemovedActual := getCRPSchedulerFinalizerRemovedActual(crpName1)
			Eventually(schedulerCleanupFinalizerRemovedActual, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to remove scheduler cleanup finalizer from CRP")
		})

		AfterAll(func() {
			// Retrieve the CRP.
			crp := &fleetv1beta1.ClusterResourcePlacement{}
			Expect(hubClient.Get(ctx, types.NamespacedName{Name: crpName1}, crp)).To(Succeed(), "Failed to get CRP")

			// Remove the additional finalizer from the CRP.
			crp.Finalizers = []string{}
			Expect(hubClient.Update(ctx, crp)).To(Succeed(), "Failed to update CRP")

			// Ensure that the CRP is deleted.
			Eventually(func() error {
				err := hubClient.Get(ctx, types.NamespacedName{Name: crpName1}, &fleetv1beta1.ClusterResourcePlacement{})
				if errors.IsNotFound(err) {
					return nil
				}

				return err
			}, eventuallyDuration, eventuallyInterval).Should(Succeed(), "Failed to delete CRP")
		})
	})
})
