/*
Copyright (c) Microsoft Corporation.
Licensed under the MIT license.
*/

package e2e

import (
	"fmt"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	. "github.com/onsi/ginkgo/v2"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	placementv1beta1 "go.goms.io/fleet/apis/placement/v1beta1"
	"go.goms.io/fleet/test/e2e/framework"
)

func workNamespaceAndDeploymentPlacedOnClusterActual(cluster *framework.Cluster) func() error {
	client := cluster.KubeClient

	workNamespaceName := fmt.Sprintf(workNamespaceNameTemplate, GinkgoParallelProcess())
	appConfigMapName := fmt.Sprintf(appConfigMapNameTemplate, GinkgoParallelProcess())

	return func() error {
		ns := &corev1.Namespace{}
		if err := client.Get(ctx, types.NamespacedName{Name: workNamespaceName}, ns); err != nil {
			return err
		}

		// Use the object created in the hub cluster as reference; this helps to avoid the trouble
		// of having to ignore default fields in the spec.
		wantNS := &corev1.Namespace{}
		if err := hubClient.Get(ctx, types.NamespacedName{Name: workNamespaceName}, wantNS); err != nil {
			return err
		}

		if diff := cmp.Diff(
			ns, wantNS,
			ignoreNamespaceStatusField,
			ignoreObjectMetaAutoGeneratedFields,
			ignoreObjectMetaAnnotationField,
		); diff != "" {
			return fmt.Errorf("work namespace diff (-got, +want): %s", diff)
		}

		configMap := &corev1.ConfigMap{}
		if err := client.Get(ctx, types.NamespacedName{Namespace: workNamespaceName, Name: appConfigMapName}, configMap); err != nil {
			return err
		}

		// Use the object created in the hub cluster as reference; this helps to avoid the trouble
		// of having to ignore default fields in the spec.
		wantConfigMap := &corev1.ConfigMap{}
		if err := hubClient.Get(ctx, types.NamespacedName{Namespace: workNamespaceName, Name: appConfigMapName}, wantConfigMap); err != nil {
			return err
		}

		if diff := cmp.Diff(
			configMap, wantConfigMap,
			ignoreObjectMetaAutoGeneratedFields,
			ignoreObjectMetaAnnotationField,
		); diff != "" {
			return fmt.Errorf("app deployment diff (-got, +want): %s", diff)
		}

		return nil
	}
}

func crpStatusUpdatedActual() func() error {
	crpName := fmt.Sprintf(crpNameTemplate, GinkgoParallelProcess())
	workNamespaceName := fmt.Sprintf(workNamespaceNameTemplate, GinkgoParallelProcess())
	appConfigMapName := fmt.Sprintf(appConfigMapNameTemplate, GinkgoParallelProcess())

	return func() error {
		crp := &placementv1beta1.ClusterResourcePlacement{}
		if err := hubClient.Get(ctx, types.NamespacedName{Name: crpName}, crp); err != nil {
			return err
		}

		wantCRPConditions := []metav1.Condition{
			{
				Type:               string(placementv1beta1.ClusterResourcePlacementScheduledConditionType),
				Status:             metav1.ConditionTrue,
				ObservedGeneration: crp.Generation,
			},
			{
				Type:               string(placementv1beta1.ClusterResourcePlacementSynchronizedConditionType),
				Status:             metav1.ConditionTrue,
				ObservedGeneration: crp.Generation,
			},
			{
				Type:               string(placementv1beta1.ClusterResourcePlacementAppliedConditionType),
				Status:             metav1.ConditionTrue,
				ObservedGeneration: crp.Generation,
			},
		}
		crpConditions := crp.Status.Conditions
		if diff := cmp.Diff(
			crpConditions, wantCRPConditions,
			cmpopts.SortSlices(lessFuncCondition),
			ignoreConditionLTTReasonAndMessageFields,
		); diff != "" {
			return fmt.Errorf("CRP conditions diff (-got, +want): %s", diff)
		}

		wantPlacementStatus := []placementv1beta1.ResourcePlacementStatus{
			{
				ClusterName: memberCluster1Name,
				Conditions: []metav1.Condition{
					{
						Type:               string(placementv1beta1.ResourceScheduledConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
					{
						Type:               string(placementv1beta1.ResourceWorkSynchronizedConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
					{
						Type:               string(placementv1beta1.ResourcesAppliedConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
				},
			},
			{
				ClusterName: memberCluster2Name,
				Conditions: []metav1.Condition{
					{
						Type:               string(placementv1beta1.ResourceScheduledConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
					{
						Type:               string(placementv1beta1.ResourceWorkSynchronizedConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
					{
						Type:               string(placementv1beta1.ResourcesAppliedConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
				},
			},
			{
				ClusterName: memberCluster3Name,
				Conditions: []metav1.Condition{
					{
						Type:               string(placementv1beta1.ResourceScheduledConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
					{
						Type:               string(placementv1beta1.ResourceWorkSynchronizedConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
					{
						Type:               string(placementv1beta1.ResourcesAppliedConditionType),
						Status:             metav1.ConditionTrue,
						ObservedGeneration: crp.Generation,
					},
				},
			},
		}
		placementStatus := crp.Status.PlacementStatuses
		if diff := cmp.Diff(
			placementStatus, wantPlacementStatus,
			cmpopts.SortSlices(lessFuncPlacementStatus),
			cmpopts.SortSlices(lessFuncCondition),
			ignoreConditionLTTReasonAndMessageFields,
		); diff != "" {
			return fmt.Errorf("CRP placement status diff (-got, +want): %s", diff)
		}

		wantSelectedResources := []placementv1beta1.ResourceIdentifier{
			{
				Kind:    "Namespace",
				Name:    workNamespaceName,
				Version: "v1",
			},
			{
				Kind:      "ConfigMap",
				Name:      appConfigMapName,
				Version:   "v1",
				Namespace: workNamespaceName,
			},
		}
		selectedResources := crp.Status.SelectedResources
		if diff := cmp.Diff(selectedResources, wantSelectedResources, cmpopts.SortSlices(lessFuncResourceIdentifier)); diff != "" {
			return fmt.Errorf("CRP selected resources diff (-got, +want): %s", diff)
		}

		return nil
	}
}

func workNamespaceAndDeploymentRemovedFromClusterActual(cluster *framework.Cluster) func() error {
	client := cluster.KubeClient

	workNamespaceName := fmt.Sprintf(workNamespaceNameTemplate, GinkgoParallelProcess())
	appConfigMapName := fmt.Sprintf(appConfigMapNameTemplate, GinkgoParallelProcess())

	return func() error {
		if err := client.Get(ctx, types.NamespacedName{Name: workNamespaceName}, &corev1.Namespace{}); !errors.IsNotFound(err) {
			return fmt.Errorf("work namespace still exists or an unexpected error occurred: %w", err)
		}

		if err := client.Get(ctx, types.NamespacedName{Namespace: workNamespaceName, Name: appConfigMapName}, &corev1.ConfigMap{}); !errors.IsNotFound(err) {
			return fmt.Errorf("app configMap still exists or an unexpected error occurred: %w", err)
		}

		return nil
	}
}

func allFinalizersExceptForCustomDeletionBlockerRemovedFromCRPActual() func() error {
	crpName := fmt.Sprintf(crpNameTemplate, GinkgoParallelProcess())

	return func() error {
		crp := &placementv1beta1.ClusterResourcePlacement{}
		if err := hubClient.Get(ctx, types.NamespacedName{Name: crpName}, crp); err != nil {
			return err
		}

		wantFinalizers := []string{customDeletionBlockerFinalizer}
		finalizer := crp.Finalizers
		if diff := cmp.Diff(finalizer, wantFinalizers); diff != "" {
			return fmt.Errorf("CRP finalizers diff (-got, +want): %s", diff)
		}

		return nil
	}
}

func crpRemovedActual() func() error {
	crpName := fmt.Sprintf(crpNameTemplate, GinkgoParallelProcess())

	return func() error {
		if err := hubClient.Get(ctx, types.NamespacedName{Name: crpName}, &placementv1beta1.ClusterResourcePlacement{}); !errors.IsNotFound(err) {
			return fmt.Errorf("CRP still exists or an unexpected error occurred: %w", err)
		}

		return nil
	}
}
